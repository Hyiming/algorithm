package 二叉树.题32.从上往下打印二叉树;import 二叉树.TreeNode;import java.util.ArrayList;import java.util.LinkedList;import java.util.Queue;public class Solution {    /**     * 算法思路，（剑指offer图片）     * 1.根节点放到队列里面，队列不空，就打印队列头，打印这个节点，马上把这个节点的左右子节点放到队列中。     * 2.再要访问一个节点，把这个节点的左右放入，此时队头是同层的，对位是打印出来的左右。依次先入先出就可以得到结果。     * @param root     * @return     */    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {//        ArrayList<Integer> list = new ArrayList<>();//        Queue<TreeNode> queue = new LinkedList<>();//        if(root == null)//            return list;//        queue.add(root);//        while (!queue.isEmpty()){//            TreeNode temp = queue.remove();//            if(temp.left != null)//                queue.add(temp.left);//            if (temp.right != null)//                queue.add(temp.right);//            list.add(temp.val);//        }//        return list;        ArrayList<Integer> list = new ArrayList<>();        Queue<TreeNode> queue = new LinkedList<>();        if (root == null) {            return list;        }        queue.add(root);        while (!queue.isEmpty()) {            TreeNode temp = queue.poll();            if (temp.left != null) {                queue.add(temp.left);            }            if (temp.right != null) {                queue.add(temp.right);            }            list.add(temp.val);        }        return list;    }}