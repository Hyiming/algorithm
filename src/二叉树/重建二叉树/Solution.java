package 二叉树.重建二叉树;import 二叉树.TreeNode;import java.util.Arrays;public class Solution {    public TreeNode reConstructBinaryTree(int[] pre, int[] in) {        if (pre == null || in == null) {            return null;        }        if (pre.length == 0 || in.length == 0) {            return null;        }        if (pre.length != in.length) {            return null;        }        TreeNode root = new TreeNode(pre[0]);//第一个        for (int i = 0; i < in.length; i++) {            if (pre[0] == in[i]) {                //pre的0往后数i个是左子树的，copyofrange包含前面的下标，不包含后面的下标                //in的i往前数i个是左子树的。                //Arrays.copyOfRange(T[] original,int from,int to)                //将一个原始的数组original，从下标from开始复制，复制到上标to，生成一个新的数组。(不包括上标to的值)                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));                //注意in是从i+1开始，因为i是现在的根，i+1开始才是右子树                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + 1, pre.length),                        Arrays.copyOfRange(in, i + 1, in.length));            }        }        return root;    }}